{
    "contents" : "#######\n#\tTo be a module mining multiple sources of target predictions\n#\tto start with - mouse - Mus musculus or human - Homo Sapiens\n#\n#######\n\nrequire(stringr)\t\t#string operations, essential\nrequire(plyr) \t\t\t#dataframe operations, do i actually use it?\n#require(RSQLite)\t\t#local sqlite db, actually I'm not using it here\n\nrequire(targetPredictor.db) #DATA\n\n\noptions(sqldf.driver = \"SQLite\") # as per FAQ #7 force SQLite\noptions(gsubfn.engine = \"R\")\n\n\n#####################\n#####################\n#\tMAIN FUNCTION\n#####################\n#####################\n\n\n\n#' Get aggregated ordered list of predicted targets for miRNA\n#'\n#' This method performs aggregation of target lists from multiple sources.\n#' Aggregated list is more accurate than any list from a single source.\n#' Multiple aggregation methods are available.\n#' \n#'\n#' @param mirna mirna in a standard format\n#' @param sources a list of sources to use for aggregation, default c('pictar','diana','targetscan','miranda')\n#' @param species species in a standard three-letter acronym, default 'mmu'\n#' @param min_src minimum number of sources required for a target to be considered, default 2\n#' @param method method of aggregation - choose from c('min', 'max', 'geom'), default 'min' is a minimum of ranks, 'max' is a maximum of ranks, and 'geom' is based on geometric mean of the ranks, it proves to be the most accurate.\n#' @param promote add weights to improve accuracy of the method, default TRUE\n#' @param ... any optional arguments\n#' @return getPredictedTargets a data.frame object where row names are entrez IDs of target genes\n#' @export\n#' @author Maciej Pajak \\email{m.pajak@@sms.ed.ac.uk}\n#' @references\n#' Friedman, R. C., Farh, K. K.-H., Burge, C. B., and Bartel, D. P. (2009). Most mammalian mRNAs are conserved targets of microRNAs. Genome research, 19(1):92-105.\n#' @references\n#' Griffiths-Jones, S., Saini, H. K., van Dongen, S., and Enright, A. J. (2008). miRBase: tools for microRNA genomics. Nucleic acids research, 36(Database issue):D154-8.\n#' @references\n#' Lall, S., Grun, D., Krek, A., Chen, K., Wang, Y.-L., Dewey, C. N., ... Rajewsky, N. (2006). A genome-wide map of conserved microRNA targets in C. elegans. Current biology : CB, 16(5):460-71.\n#' @references\n#'\tMaragkakis, M., Vergoulis, T., Alexiou, P., Reczko, M., Plomaritou, K., Gousis, M., ... Hatzigeorgiou, A. G. (2011). DIANA-microT Web server upgrade supports Fly and Worm miRNA target prediction and bibliographic miRNA to disease association. Nucleic Acids Research, 39(Web Server issue), W145-8.\n#' @examples\n#' ##Not run:\n#' targets = getPredictedTargets('let-7a',species='mmu') \n#' head(targets) #top of the list\ngetPredictedTargets = function(mirna,sources=c('pictar','diana','targetscan','miranda'),species='mmu', min_src=2, method='min', promote=TRUE, ...) {\n\t\n\tif (!(species %in% c('mmu','hsa','rno','dme'))) {\n\t\tmessage(paste('species ',species,' not supported in the current version',sep=''))\n\t\treturn(NULL)\n\t}\n\t \n\tconL = get_connection()\n\t\n\tn_sources = length(sources)\n\t\n\tmessage(paste('sources: ',n_sources,sep=''))\n\tif (n_sources<min_src) {\n\t\t#!! either 'repair' it or inform the user that they're stupid\n\t\t# well in this case rather the latter, right?\n\t\tmessage('min_src > n_sources!')\n\t\treturn(NULL)\n\t}\n\t\n\tif (min_src<=0) {\n\t\tmessage('min_src changed to 1')\n\t\tmin_src = 1\n\t}\n\t\n\tif (nchar(mirna)<3) {\n\t\tmessage('unrecognised miRNA')\n\t\treturn(NULL)\n\t}\n\t\n\t#h_outputs = hash()\n\t\n\tl_outputs = list()\n\t\n\tcols=c('GeneID','score')\n\t\n\tif (substr(mirna,1,3)==species) {\n\t\tmirna=substr(mirna,5,15)\n\t}\n\t\n\t#!!extract ifs below into a wrapper on getters DONE\n\t#this is the important step - obtaining all target lists\n\tfor (src in sources) {\n\t#!! but what if theres just one source\n\t\tl_outputs[[src]]=getTargetsFromSource(mirna,species,conL,source=src)\n\t}\n\t\n\t\n\t#watch out - it creates non-unique colnames!\n\tmerged.scores = suppressWarnings(Reduce(function(...) merge_rename(..., by='GeneID', all=TRUE), l_outputs))\n\t\n\t#print(merged.scores)\n\t#print(dim(merged.scores))\n\t\n\tif (dim(merged.scores)[1]<1) { # \n\t\tmessage(paste('no targets found for mirna ',mirna,sep=''))\n\t\treturn(NULL)\n\t}\n\t\n\tvalid_srcs = (1:(n_sources+1))[colSums(merged.scores,na.rm = TRUE)>0]\n\t#print(valid_srcs)\n\t\n\tn_valid_srcs = length(valid_srcs)-1\n\t#print(n_valid_srcs)\n\t\n\tif (n_valid_srcs<min_src) {\n\t\t#!!technically that's not user's mistake, it should get repaired automatically\n\t\t#and some sort of warning should be given\n\t\tmessage(paste('algos which returned a target list<min_src, min_src reduced to ',n_valid_srcs,sep=''))\n\t\tmin_src = n_valid_srcs\n\t\t#return(NULL)\n\t}\t\n\t\n\tmerged.scores = merged.scores[,valid_srcs]\n\t\n\tif (n_valid_srcs>1) {\n\t\ttarget_found = rowSums(!is.na(merged.scores[,2:(n_valid_srcs+1)])) #n_sources\n\t} else {\n\t\ttarget_found = 1*(!is.na(merged.scores[,2:(n_valid_srcs+1)])) #n_sources\n\t}\n\t#max_appears=max(target_found) #possibly? used it in the paper\n\t\n\t\n\tmerged.scores2 = merged.scores[target_found>=min_src,]\n\t\n\t#duplicate removal needs to go at the level of a single result list\n\t#!! so it means that we don't need this line...\n\tmerged.scores3 = merged.scores2[!duplicated(merged.scores2$GeneID),]\n\t\n\tmerged.scores3 = merged.scores3[!is.na(merged.scores3$GeneID),]\n  \n\trow.names(merged.scores3) = merged.scores3$GeneID\n\t\n\t#RELEVANT LINES COPIED FROM RP\n\tdata1 = merged.scores3[,2:(n_valid_srcs+1)] #n_sources\n\t\n\tdata1 = as.data.frame(data1)\n\t\n\t#data2 = data1[,NULL]\n\t\n\tnum.gene = dim(data1)[1]\n\t\n\t#message(dim(data1))\n\t\n\t\n\tif (num.gene<1) {\n\t\tmessage('not enough targets overlapping between sources, reduce min_srcs parameter or add sources')\n\t\treturn(NULL)\n\t} else if (num.gene==1) {\n\t\tmessage('only one target found')\n\t\tresult = data.frame(matrix(1,nrow=1,ncol=n_valid_srcs+2))\n\t\tcolnames(result)=c(paste('source_',1:n_valid_srcs,sep=''),'rank_product','rank_final')\n\t\trow.names(result) = row.names(data1)\n\t\treturn(result)\n\t}\n\t\n\t#we need to reverse rank them\n\trank.rep = apply(data1, 2, function(x) (num.gene+1) - rank(x, ties.method='average', na.last = FALSE))\n\tnum.rank = apply(is.na(data1) == FALSE, 1, sum)\n\t\n\t\n\t\n\tif (method=='geom') {\n\t\trank.rep[is.na(data1)] = 1\n\t\t\n\t\tif (promote==TRUE) {\n\t\t\trank.prod = (1/num.rank)*(apply(rank.rep, 1, prod))^(1/num.rank)\n\t\t} else {\n\t\t\trank.prod = (apply(rank.rep, 1, prod))^(1/num.rank)\n\t\t}\n\t\trank.prod[num.rank == 0] = NA #icing - all NAs won't happen anyway, !!so delete?\n\t\t\n\t\trank.ori <- rank(rank.prod)\n\t\t\n\t\t\n\t\trank.rep[is.na(data1)] = NA\n\t\tresult = cbind(rank.rep,rank.prod,rank.ori)  #,pval.downin2\n \t\tresult = result[order(result[,'rank.ori']),]\n\t\n\t}  else if (method=='max') {\n\t\n\t\trank.rep[is.na(data1)] = NA\n\t\trank.prod = apply(rank.rep, 1, max, na.rm=TRUE)\n\t\trank.ori <- rank(rank.prod)\n\t\tresult = cbind(rank.rep,rank.prod,rank.ori)\n\t\tresult = result[order(result[,'rank.ori']),]\n\t\n\t} else  { #even if it's something invalid, still use min\n\t\n\t\trank.rep[is.na(data1)] = NA\n\t\trank.prod = apply(rank.rep, 1, min, na.rm=TRUE)\n\t\trank.ori <- rank(rank.prod)\n\t\tresult = cbind(rank.rep,rank.prod,rank.ori)\n\t\tresult = result[order(result[,'rank.ori']),]\n\t\t\t\n\t} \n\t\n\t\n\tdbDisconnect(conL)\n\t\n\tcolnames(result)=c(paste('source_',1:n_valid_srcs,sep=''),'rank_product','rank_final') #coating\n\treturn(result)\n}\n\n\n\n\n#####################\n#\t\n#####################\n\n#' Auxiliary internal TargetPredictor functions\n#'\n#' This function is not meant to be called directly by the user\n#'\n#' @export\n#' @author Maciej Pajak \\email{m.pajak@@sms.ed.ac.uk}\t\nmerge_rename = function(...) {\n\tmerged = merge(...)\n\tcolnames(merged) = c(colnames(merged)[1],paste('V',1:(length(names(merged))-1),sep=''))\n\treturn(merged)\n}\n\n####################\n#\tuseless stuff\n####################\n#bin?\n# generate_csv = function(mir,species='mmu',...) {\n\t\n\t# ao = getPredictedTargets(mir, species=species,method='geom',min_src=2)\n\t# xo = as.data.frame(ao)\n\t# xo$entrez = row.names(ao)\n\t# xo = xo[,c('entrez','rank.prod','rank.ori','pval.downin2')]\n\t\n\t# filename = paste(species,'-',mir,'.csv',sep='')\n\t# write.csv(xo, filename, row.names=FALSE)\n\t\n# }\n",
    "created" : 1396036497495.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3887957397",
    "id" : "7E3C9C3D",
    "lastKnownWriteTime" : 1398797421,
    "path" : "C:/Users/Maciej/workspace-R/targetPredictor/R/targetpredictor.r",
    "project_path" : "R/targetpredictor.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}